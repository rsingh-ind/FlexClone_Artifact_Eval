25,33d24
< 
< //#include <sys/types.h>
< //#include <sys/stat.h>
< //#include <unistd.h>
< //#include <assert.h>
< //#define _GNU_SOURCE	//reqd. for strchrnul()
< //#include <string.h>
< #include <sys/syscall.h>
< 
25126,25133d25116
< double what_time_is_it()
< {
<     struct timespec now;
<     clock_gettime(CLOCK_REALTIME, &now);
<     //printf("now.tv_sec: %ld, now.tv_nsec: %ld\n", now.tv_sec, now.tv_nsec);
<     return (double)now.tv_sec + ((double)now.tv_nsec)*1e-9;
< }
< 
31163,31165d31145
< //scorw start
< //
<      
31171,31173d31150
< 
<       //do{ fmt++; }while( *fmt && *fmt != '%' );
< //scorw end
38175d38151
< // scorw start
38187d38162
< //scorw end //
38472d38446
< // scorw start
38480d38453
< //scorw end //
52941d52913
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
58628,58639d58599
< ** Discard the entire contents of the in-memory page-cache except page 1
< */
< static void scorw_pager_reset(Pager *pPager)
< {
<   pPager->iDataVersion++;
<   sqlite3BackupRestart(pPager->pBackup);
<   //Start cleanup of page cache from page 2.
<   //We don't want page 1's contents to be zeroed out. 
<   sqlite3PcacheTruncate( pPager->pPCache, 1);
< }
< 
< /*
58735,58741c58695
< 	//scorw start
<       //sqlite3OsClose(pPager->jfd);
<       	if(PAGER_JOURNALMODE_DELETE != pPager->journalMode)
< 	{
< 	      sqlite3OsClose(pPager->jfd);
< 	}
< 	//scorw end
---
>       sqlite3OsClose(pPager->jfd);
58814d58767
<     printf("%s(): error error error error\n", __func__);
58966,58973c58919
<       //scorw start
<       //static unsigned int called = 0;
<       //called++;
<       //printf("%s(), called for %d times\n", __func__, called);
<       //sqlite3OsClose(pPager->jfd);
<       pPager->jfd->pMethods = 0;	//Recall, non-zero value of pMethods
<       					//implies that the journal is open
<       //scorw end 
---
>       sqlite3OsClose(pPager->jfd);
58975,58992c58921
< 	//scorw start
<         //rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
< 	int ret = 0;
< 	int buffer_size = 256;
< 	char setxattr_cmd[buffer_size];
< 	//sprintf(setxattr_cmd, "rm -f %s_child %s_frnd", pPager->zFilename, pPager->zFilename);
< 	//ret = system(setxattr_cmd);
< 	memset(setxattr_cmd, '\0', buffer_size);
< 	sprintf(setxattr_cmd, "%s_child", pPager->zFilename);
< 	ret = unlink(setxattr_cmd);
< 	assert(ret == 0);
< 
< 	memset(setxattr_cmd, '\0', buffer_size);
< 	sprintf(setxattr_cmd, "%s_frnd", pPager->zFilename);
< 	ret = unlink(setxattr_cmd);
< 	assert(ret == 0);
<         //printf("%s(), journal file deleted\n", __func__);
<         //scorw end 
---
>         rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
59694,59724c59623,59625
< 
< 
<   /**********************************************
<    * scorw Note:				*
<    * 	Have deleted the original contents of	* 
<    * 	this function. Added own logic now.	*
<    **********************************************/
< 
<   /////////////////////////////////////////////////////////////////////////////////////////
<   //Scorw Update
<   /////////////////////////////////////////////////////////////////////////////////////////
<   //* We have modified the code in write path s.t. data is not copied to journal
<   //  on every write. Instead data is copied to journal only when a write operation
<   //  happens on database file.
<   //
<   // * When we do modifications insertion/deletion/updation inside the BEGIN TRANSACTION
<   //   code block, these modification are performed on cache pages and not on database
<   //   file.
<   //
<   // * As a result, as per our logic, no data is being copied to journal file because
<   //   modifications never happened in journal file.
<   //
<   // * So, to perform rollback, all we have to do is to discard the changes made
<   //   to the pages in page cache and then cleanup the journal file.
<   /////////////////////////////////////////////////////////////////////////////////////////
< 
<   //scorw start
<         //static unsigned int called = 0;
<       //called++;
<       //printf("%s(), called for %d times\n", __func__, called);
< 
---
>   /* Figure out how many records are in the journal.  Abort early if
>   ** the journal is empty.
>   */
59725a59627,59630
>   rc = sqlite3OsFileSize(pPager->jfd, &szJ);
>   if( rc!=SQLITE_OK ){
>     goto end_playback;
>   }
59727,59778c59632,59653
<   
<   int i = 0;
<   int p = 0;
<   int ret = 0;
<   int bufSize = 1024;
<   int pageSizeBits = 12;
<   char childName[bufSize];
<   struct stat statbuf;
<   int pageSize = 4096;
<   char frndName[bufSize];
<   //unsigned long origParSize = 0;
<   //i64 newSize = 0;
<   int childfd = 0;
<   int frndfd = 0;
<   int parfd = 0;
<   int byte = 0;
<   unsigned long offset = 0;
<   char data[pageSize];
<   char buf[pageSize];
<   
< 
<   //Note:
<   //	Eventhough sqlite stores changes made during a transaction in 
<   //	memory but consider the case when database is large and page cache
<   //	limit is reached. In this case, some of the pages will be flushed
<   //	to disk. 
<   //	Hence, some blocks will be copied to our child file.
<   //	During rollback, such pages should be restored from child to parent
<   //
<   memset(childName, '\0', bufSize);
<   sprintf(childName, "%s_child", pPager->zFilename);
< 
<   memset(frndName, '\0', bufSize);
<   sprintf(frndName, "%s_frnd", pPager->zFilename);
< 
< 
<   //truncate database file (par file)
<   //Note that truncation can lead to increase (or) decrease
<   //of db file size
<   ret = stat(childName, &statbuf);
<   assert(ret == 0);
< 
<   ret = truncate(pPager->zFilename, statbuf.st_size);
<   assert(ret == 0);
< 
<   //Copy contents of pages from journal file (child file) to 
<   //database file (par file)
<   parfd = open(pPager->zFilename, O_RDWR);
<   assert(parfd >= 0);
< 
<   childfd = open(childName, O_RDONLY);
<   assert(childfd >= 0);
---
>   /* Read the super-journal name from the journal, if it is present.
>   ** If a super-journal file name is specified, but the file is not
>   ** present on disk, then the journal is not hot and does not need to be
>   ** played back.
>   **
>   ** TODO: Technically the following is an error because it assumes that
>   ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that
>   ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,
>   ** mxPathname is 512, which is the same as the minimum allowable value
>   ** for pageSize.
>   */
>   zSuper = pPager->pTmpSpace;
>   rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);
>   if( rc==SQLITE_OK && zSuper[0] ){
>     rc = sqlite3OsAccess(pVfs, zSuper, SQLITE_ACCESS_EXISTS, &res);
>   }
>   zSuper = 0;
>   if( rc!=SQLITE_OK || !res ){
>     goto end_playback;
>   }
>   pPager->journalOff = 0;
>   needPagerReset = isHot;
59780,59781c59655,59671
<   frndfd = open(frndName, O_RDONLY);
<   assert(frndfd >= 0);
---
>   /* This loop terminates either when a readJournalHdr() or
>   ** pager_playback_one_page() call returns SQLITE_DONE or an IO error
>   ** occurs.
>   */
>   while( 1 ){
>     /* Read the next journal header from the journal file.  If there are
>     ** not enough bytes left in the journal file for a complete header, or
>     ** it is corrupted, then a process must have failed while writing it.
>     ** This indicates nothing more needs to be rolled back.
>     */
>     rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
>     if( rc!=SQLITE_OK ){
>       if( rc==SQLITE_DONE ){
>         rc = SQLITE_OK;
>       }
>       goto end_playback;
>     }
59783c59673,59681
<   offset = 0;
---
>     /* If nRec is 0xffffffff, then this journal was created by a process
>     ** working in no-sync mode. This means that the rest of the journal
>     ** file consists of pages, there are no more journal headers. Compute
>     ** the value of nRec based on this assumption.
>     */
>     if( nRec==0xffffffff ){
>       assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );
>       nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));
>     }
59785,59827c59683,59700
<   while((ret = read(frndfd, buf, pageSize)) == pageSize)
<   {
< 	  //printf("Read 4KB from frnd file\n");
< 	  for(p = 0; p < pageSize; p++)
< 	  {	
< 		  //printf("byte %d: %d, \n", p, buf[p]);
< 		  byte = buf[p];
< 		  if(byte == 0)
< 		  {
< 			  offset += pageSize * 8;
< 			  continue;
< 		  }
< 		  //printf("******** Some blks are present in child file *********\n");
< 		  for(i = 0; i < 8; i++)
< 		  {
< 			  if(((byte >> i) & 0x1) == 1)
< 			  {
< 				 ret = pread(childfd, data, pageSize, offset);
< 				 assert(ret == pageSize);
< 
< 				 ret = pwrite(parfd, data, pageSize, offset);
< 				 assert(ret == pageSize);
< 			  }
< 			  offset += pageSize;
< 		  }
< 	}
<   }
<   assert(ret == 0);
<  
< 
< 
<   //reset pager members
<   //pPager->journalOff = 0;
<   //pPager->dbSize = statbuf.st_size >> pageSizeBits;	//Recall, dbSize is in pages
<   							//and page numbering starts from 1
<   //pPager->mxPgno = pPager->dbSize;
<   
<   //one of the pager membes is dbFileVers
<   //Restore it to the older value
<   //It's value is stored in the first page of the db
<   //(Recall, 1st page always gets modified on a write)
<   //ret = pread(parfd, data, pageSize, 0);
<   //assert(ret == pageSize);
---
>     /* If nRec is 0 and this rollback is of a transaction created by this
>     ** process and if this is the final header in the journal, then it means
>     ** that this part of the journal was being filled but has not yet been
>     ** synced to disk.  Compute the number of pages based on the remaining
>     ** size of the file.
>     **
>     ** The third term of the test was added to fix ticket #2565.
>     ** When rolling back a hot journal, nRec==0 always means that the next
>     ** chunk of the journal contains zero pages to be rolled back.  But
>     ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in
>     ** the journal, it means that the journal might contain additional
>     ** pages that need to be rolled back and that the number of pages
>     ** should be computed based on the journal file size.
>     */
>     if( nRec==0 && !isHot &&
>         pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){
>       nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));
>     }
59829c59702,59714
<   //memcpy(&pPager->dbFileVers, &(data[24]), sizeof(pPager->dbFileVers));
---
>     /* If this is the first header read from the journal, truncate the
>     ** database file back to its original size.
>     */
>     if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){
>       rc = pager_truncate(pPager, mxPg);
>       if( rc!=SQLITE_OK ){
>         goto end_playback;
>       }
>       pPager->dbSize = mxPg;
>       if( pPager->mxPgno<mxPg ){
>         pPager->mxPgno = mxPg;
>       }
>     }
59831,59837c59716,59748
<   pPager->journalOff = 0;
<   pPager->dbSize = statbuf.st_size >> pageSizeBits;	//Recall, dbSize is in pages
<   							//and page numbering starts from 1
<   pPager->dbFileSize = pPager->dbSize;
<   if(pPager->mxPgno < pPager->dbSize)
<   {
<         pPager->mxPgno = pPager->dbSize;
---
>     /* Copy original pages out of the journal and back into the
>     ** database file and/or page cache.
>     */
>     for(u=0; u<nRec; u++){
>       if( needPagerReset ){
>         pager_reset(pPager);
>         needPagerReset = 0;
>       }
>       rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
>       if( rc==SQLITE_OK ){
>         nPlayback++;
>       }else{
>         if( rc==SQLITE_DONE ){
>           pPager->journalOff = szJ;
>           break;
>         }else if( rc==SQLITE_IOERR_SHORT_READ ){
>           /* If the journal has been truncated, simply stop reading and
>           ** processing the journal. This might happen if the journal was
>           ** not completely written and synced prior to a crash.  In that
>           ** case, the database should have never been written in the
>           ** first place so it is OK to simply abandon the rollback. */
>           rc = SQLITE_OK;
>           goto end_playback;
>         }else{
>           /* If we are unable to rollback, quit and return the error
>           ** code.  This will cause the pager to enter the error state
>           ** so that no further harm will be done.  Perhaps the next
>           ** process to come along will be able to rollback the database.
>           */
>           goto end_playback;
>         }
>       }
>     }
59838a59750,59751
>   /*NOTREACHED*/
>   assert( 0 );
59840,59872c59753,59764
<  
< 
<   //Discard the page cache pages of pager
<   //(Because, their content has become stale.)
<   //Update:
<   //	Discarded later in sqlite3BtreeRollback()
<   //scorw_pager_reset(pPager);
< 
<   sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);
< 
<   //Update the database size (num pages) in the database file
<   //(Came to know from the lockBtree() about the offset of 28)
<   //
<   //u32 tmp = 0;
<   //read32bits(pPager->fd, 28, &tmp);
<   //printf("Rollback: File size stored in db file (%s on disk), before we modified it: %x\n", pPager->zFilename, tmp);
<   //printf("Rollback: File size trying to store in db file (on disk): %x , addr of var: %lx\n", pPager->dbSize, &(pPager->dbSize));
<   write32bits(pPager->fd, 28, pPager->dbSize);
< 
<   //sync database file before journal gets deleted
<   sqlite3PagerSync(pPager, 0);
< 
<   //cleanup journal file
<   //The write transaction open on pPager is being committed (bCommit==1)
<   //or rolled back (bCommit==0).
<   pager_end_transaction(pPager, 0, 0);
< 
<   //printf("Rollback: db file name: %s\n", pPager->zFilename);
< 
<   //close fd's
<   close(parfd);
<   close(childfd);
<   close(frndfd);
---
> end_playback:
>   if( rc==SQLITE_OK ){
>     rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);
>   }
>   /* Following a rollback, the database file should be back in its original
>   ** state prior to the start of the transaction, so invoke the
>   ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the
>   ** assertion that the transaction counter was modified.
>   */
> #ifdef SQLITE_DEBUG
>   sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
> #endif
59874c59766,59775
<   setSectorSize(pPager);
---
>   /* If this playback is happening automatically as a result of an IO or
>   ** malloc error that occurred after the change-counter was updated but
>   ** before the transaction was committed, then the change-counter
>   ** modification may just have been reverted. If this happens in exclusive
>   ** mode, then subsequent transactions performed by the connection will not
>   ** update the change-counter at all. This may lead to cache inconsistency
>   ** problems for other processes at some point in the future. So, just
>   ** in case this has happened, clear the changeCountDone flag now.
>   */
>   pPager->changeCountDone = pPager->tempFile;
59875a59777,59807
>   if( rc==SQLITE_OK ){
>     /* Leave 4 bytes of space before the super-journal filename in memory.
>     ** This is because it may end up being passed to sqlite3OsOpen(), in
>     ** which case it requires 4 0x00 bytes in memory immediately before
>     ** the filename. */
>     zSuper = &pPager->pTmpSpace[4];
>     rc = readSuperJournal(pPager->jfd, zSuper, pPager->pVfs->mxPathname+1);
>     testcase( rc!=SQLITE_OK );
>   }
>   if( rc==SQLITE_OK
>    && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)
>   ){
>     rc = sqlite3PagerSync(pPager, 0);
>   }
>   if( rc==SQLITE_OK ){
>     rc = pager_end_transaction(pPager, zSuper[0]!='\0', 0);
>     testcase( rc!=SQLITE_OK );
>   }
>   if( rc==SQLITE_OK && zSuper[0] && res ){
>     /* If there was a super-journal and this routine will return success,
>     ** see if it is possible to delete the super-journal.
>     */
>     assert( zSuper==&pPager->pTmpSpace[4] );
>     memset(pPager->pTmpSpace, 0, 4);
>     rc = pager_delsuper(pPager, zSuper);
>     testcase( rc!=SQLITE_OK );
>   }
>   if( isHot && nPlayback ){
>     sqlite3_log(SQLITE_NOTICE_RECOVER_ROLLBACK, "recovered %d pages from %s",
>                 nPlayback, pPager->zJournal);
>   }
59877,59878c59809,59814
<   return SQLITE_OK;
<   //scorw end
---
>   /* The Pager.sectorSize variable may have been updated while rolling
>   ** back a journal created by a process with a different sector size
>   ** value. Reset it to the correct value for this process.
>   */
>   setSectorSize(pPager);
>   return rc;
59898,59903d59833
<      //scorw start
<       //static unsigned int called = 0;
<       //called++;
<       //printf("%s(), called for %d times. Called for page num: %d\n", __func__, called, pPg->pgno);
<       //scorw end
< 
59920,59922d59849
<         //double t1 = 0.0;
<         //double t2 = 0.0;
<         //t1 = what_time_is_it();
59924,59925d59850
<         //t2 = what_time_is_it();
<         //printf("%s(): %g\n", __func__, (t2-t1)*1000000);
61163,61164d61087
<   //scorw start. Is below exclusive lock reqd?
<   /*
61175,61196c61098,61119
<         // This block deals with an obscure problem. If the last connection
<         // that wrote to this database was operating in persistent-journal
<         // mode, then the journal file may at this point actually be larger
<         // than Pager.journalOff bytes. If the next thing in the journal
<         // file happens to be a journal-header (written as part of the
<         // previous connection's transaction), and a crash or power-failure
<         // occurs after nRec is updated but before this connection writes
<         // anything else to the journal file (or commits/rolls back its
<         // transaction), then SQLite may become confused when doing the
<         // hot-journal rollback following recovery. It may roll back all
<         // of this connections data, then proceed to rolling back the old,
<         // out-of-date data that follows it. Database corruption.
<         //
<         // To work around this, if the journal file does appear to contain
<         // a valid header following Pager.journalOff, then write a 0x00
<         // byte to the start of it to prevent it from being recognized.
<         //
<         // Variable iNextHdrOffset is set to the offset at which this
<         // problematic header will occur, if it exists. aMagic is used
<         // as a temporary buffer to inspect the first couple of bytes of
<         // the potential journal header.
<         //
---
>         /* This block deals with an obscure problem. If the last connection
>         ** that wrote to this database was operating in persistent-journal
>         ** mode, then the journal file may at this point actually be larger
>         ** than Pager.journalOff bytes. If the next thing in the journal
>         ** file happens to be a journal-header (written as part of the
>         ** previous connection's transaction), and a crash or power-failure
>         ** occurs after nRec is updated but before this connection writes
>         ** anything else to the journal file (or commits/rolls back its
>         ** transaction), then SQLite may become confused when doing the
>         ** hot-journal rollback following recovery. It may roll back all
>         ** of this connections data, then proceed to rolling back the old,
>         ** out-of-date data that follows it. Database corruption.
>         **
>         ** To work around this, if the journal file does appear to contain
>         ** a valid header following Pager.journalOff, then write a 0x00
>         ** byte to the start of it to prevent it from being recognized.
>         **
>         ** Variable iNextHdrOffset is set to the offset at which this
>         ** problematic header will occur, if it exists. aMagic is used
>         ** as a temporary buffer to inspect the first couple of bytes of
>         ** the potential journal header.
>         */
61214,61224c61137,61147
<         // Write the nRec value into the journal file header. If in
<         // full-synchronous mode, sync the journal first. This ensures that
<         // all data has really hit the disk before nRec is updated to mark
<         // it as a candidate for rollback.
<         //
<         // This is not required if the persistent media supports the
<         // SAFE_APPEND property. Because in this case it is not possible
<         // for garbage data to be appended to the file, the nRec field
<         // is populated with 0xFFFFFFFF when the journal header is written
<         // and never needs to be updated.
<         //
---
>         /* Write the nRec value into the journal file header. If in
>         ** full-synchronous mode, sync the journal first. This ensures that
>         ** all data has really hit the disk before nRec is updated to mark
>         ** it as a candidate for rollback.
>         **
>         ** This is not required if the persistent media supports the
>         ** SAFE_APPEND property. Because in this case it is not possible
>         ** for garbage data to be appended to the file, the nRec field
>         ** is populated with 0xFFFFFFFF when the journal header is written
>         ** and never needs to be updated.
>         */
61256,61257c61179
< */
< //scorw end
---
> 
62421,62425c62343
<   if( pgno==0 ) 
<   { 
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( pgno==0 ) return SQLITE_CORRUPT_BKPT;
62457d62374
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
62541d62457
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
62620,62629c62536
<   //double t1 = 0.0;
<   //double t2 = 0.0;
<   //t1 = what_time_is_it();
< 
<   int ret = pPager->xGet(pPager, pgno, ppPage, flags);
< 
<   //t2 = what_time_is_it();
<   //printf("[pid: %u, tid: %u] %s(): Page number: %u, %g, cache hits: %lu, cache misses: %lu\n", getpid(), syscall(SYS_gettid), __func__, pgno, (t2-t1)*1000000, pPager->aStat[PAGER_STAT_HIT], pPager->aStat[PAGER_STAT_MISS]);
< 
<   return ret;
---
>   return pPager->xGet(pPager, pgno, ppPage, flags);
62694,62882d62600
< #include <stdio.h>
< #include <stdlib.h>
< #include <string.h>
< #include <sys/types.h>
< #include <sys/stat.h>
< #include <fcntl.h>
< #include <unistd.h>
< #include <sys/ioctl.h>
< #include <assert.h>
< #include <sys/types.h>
< #include <sys/xattr.h>
< 
< #define MAX_RANGES_SUPPORTED    4
< #define BLOCK_SIZE              4096    //4 KB block
< #define BLOCK_SIZE_BITS         12      //4 KB block
< 
< //range is inclusive of start and end
< //Block numbers start from 0
< struct child_range
< {
<         long long start;        //start block num
<         long long end;          //end block num
< };
< 
< struct helper_inodes
< {
<         unsigned long p_inode;  //parent's inode
<         unsigned long f_inode;  //friend's inode
<         int num_ranges;         //how many ranges to store corresponding a child?
<         struct child_range range[MAX_RANGES_SUPPORTED]; //maintain static snapshot of these blocks
< };
< 
< void scorw_setxattr(int argc, char *argv[])
< {
<         int i = 0;
<         int cfd = -1;
<         int pfd = -1;
<         int ffd = -1;
<         int pInoNum = -1;
<         int ret = 0;
<         int value = 0;
<         struct stat statbuf;
<         struct helper_inodes h_inodes;
<         int valid_args_count = 0;
<         int basic_args_count = 4;               //4 basic args  ./prog <child file> <parent file> <friend file>
<         int max_args_count = basic_args_count + (MAX_RANGES_SUPPORTED * 2);     //basic args + 2 args per range
<         long long prev_blk_num = -1;
<         long long cur_blk_num = -1;
<         long long num_par_blks = 0;
<         int invalid_range_arg = 0;
<         int num_ranges = 0;
< 
<         char *attr_name = "user.SCORW_PARENT";
< 
<         //Make sure the count of the args passed is correct
<         for(i = basic_args_count; i <= max_args_count; i=i+2)
<         {
<                 if(i == argc)
<                 {
<                         valid_args_count = 1;
<                         break;
<                 }
<         }
< 
<         if(!valid_args_count)
<         {
<                 printf("syntax: ./prog <child file> <parent file> <friend file> [start end start end ..]\n");
<                 printf("Note: Currently max %d ranges are allowed\n", MAX_RANGES_SUPPORTED);
<                 //return -1;
< 		exit(-1);
<         }
< 
<         //printf("Opening files\n");
<         cfd = open(argv[1], O_RDWR | O_CREAT, 0644);
<         assert(cfd >= 0);
< 
<         pfd = open(argv[2], O_RDWR);
<         assert(pfd >= 0);
< 
<         ffd = open(argv[3], O_RDWR | O_CREAT, 0644);
<         assert(ffd >= 0);
< 
<         //printf("Performing fstat call\n");
<         fstat(pfd, &statbuf);
<         h_inodes.p_inode = statbuf.st_ino;
<         num_par_blks = (((statbuf.st_size) % BLOCK_SIZE) == 0) ? (statbuf.st_size >> BLOCK_SIZE_BITS) : (1 + (statbuf.st_size >> BLOCK_SIZE_BITS));
< 
<         fstat(ffd, &statbuf);
<         h_inodes.f_inode = statbuf.st_ino;
<         //printf("Returned from fstat call\n");
< 
<         //Initially, no range is valid
<         for(i=0; i < MAX_RANGES_SUPPORTED; i++)
<         {
<                 h_inodes.range[i].start = -1;
<                 h_inodes.range[i].end = -1;
<         }
< 
<         //perform sanity checks on the range arguments
<         //1) No 2 ranges should overlap
<         //2) Ranges should be in increasing order
<         //3) Range can't be negative
<         //4) Range should fit in par file size
<         prev_blk_num = -1;
<         invalid_range_arg = 0;
<         for(i=basic_args_count; i<argc; i++)
<         {
<                 cur_blk_num = atoll(argv[i]);
< 
<                 //ranges overlap (or) ranges are not in increasing order (or) range is negative
<                 if(cur_blk_num <= prev_blk_num)
<                 {
<                         invalid_range_arg = 1;
<                         break;
<                 }
< 
<                 //Range doesn't fit par file size
<                 if(cur_blk_num >= num_par_blks)
<                 {
<                         invalid_range_arg = 2;
<                         break;
<                 }
<                 prev_blk_num = cur_blk_num;
<         }
< 
<         if(invalid_range_arg)
<         {
<                 if(invalid_range_arg == 1)
<                 {
<                         printf("Error: ranges overlap (or) ranges are not in increasing order (or) range is negative\n");
<                 }
<                 else if(invalid_range_arg == 2)
<                 {
<                         printf("Error: range doesn't fit par file size\n");
<                 }
<                 else
<                 {
<                         printf("Error: some other range error\n");
<                 }
<                 //return -1;
< 		exit(-1);
<         }
< 
<         //prepare range array
<         num_ranges = ((argc - basic_args_count) / 2);
<         if(num_ranges == 0)
<         {
<                 //No range supplied. So, cover full range.
<                 h_inodes.range[0].start = 0;
<                 h_inodes.range[0].end = num_par_blks-1;
<                 h_inodes.num_ranges = 1;
<         }
<         else
<         {       //Cover provided range
<                 for(i=0; i < num_ranges; i++)
<                 {
<                         h_inodes.range[i].start = atoll(argv[(2*i)+basic_args_count]);
<                         h_inodes.range[i].end = atoll(argv[(2*i)+1+basic_args_count]);
<                 }
<                 h_inodes.num_ranges = num_ranges;
<         }
< 
<         /*
<         for(i=0; i < MAX_RANGES_SUPPORTED; i++)
<         {
<                 printf("Range %d: %lld:%lld, num_par_blks: %lld, h_inodes.num_ranges: %d\n", i, h_inodes.range[i].start, h_inodes.range[i].end, num_par_blks, h_inodes.num_ranges);
<         }
<         */
< 
< 
<         //printf("Performing setxattr call\n");
<         ret = fsetxattr(cfd, attr_name , &h_inodes, sizeof(struct helper_inodes), 0);
<         if(ret == -1)
<         {
<                 perror("setxattr failed");
<                 //return -1;
< 		exit(-1);
<         }
<         //printf("Returned from setxattr call\n");
< 
< 
<         //printf("closing files\n");
<         close(cfd);
<         close(pfd);
<         close(ffd);
< 
<         //return 0;
< }
< 
62909,62910d62626
<   //printf("%s() called\n", __func__);
< 
62947,62951d62662
< 	//scorw start
<       //static unsigned int called = 0;
<       //called++;
<       //printf("%s(), called for %d times\n", __func__, called);
< 	  /*
62955,62995d62665
< 	  */
< 	pPager->jfd->pMethods = (const sqlite3_io_methods*)0x1; 	//Set some non-zero value, so that, isOpen() assertions
< 					//don't fail. Refer implementation of 
< 					//isOpen() to see how it decides whether the 
< 					//journal is open or not.
< 					//Also, see sqlite3JournalOpen() to know
< 					//what is the actual value stored in 
< 					//pMethods pointer.
< 	int ret = 0;
< 	int num_args = 4;
< 	int buf_size = 256;
< 	char child_name[buf_size];
< 	char frnd_name[buf_size];
< 	char *cmd[num_args];
< 
< 	//printf("%s(): pPager->journalMode: %d\n", __func__, pPager->journalMode);
< 	// Is this deletion operation reqd? After clean completion of a transaction,
< 	// both child and frnd file are deleted in sqlite3PagerCommitPhaseTwo().
< 	// Only in case of crash they won't be deleted
< 	// We are assuming no crash will happen.
< 	//
< 	//memset(setxattr_cmd, '\0', buffer_size);
< 	//sprintf(setxattr_cmd, "rm -f %s_child %s_frnd", pPager->zFilename, pPager->zFilename);
< 	//ret = system(setxattr_cmd);
< 	
< 	memset(child_name, '\0', buf_size);
< 	memset(frnd_name, '\0', buf_size);
< 	sprintf(child_name, "%s_child", pPager->zFilename);
< 	sprintf(frnd_name, "%s_frnd", pPager->zFilename);
< 
< 	cmd[0] = "./setxattr";
< 	cmd[1] = child_name;
< 	cmd[2] = pPager->zFilename;	
< 	cmd[3] = frnd_name;
< 
< 	scorw_setxattr(num_args, cmd);
<         //printf("%s(), journal file created\n", __func__);
< 
< 	rc = SQLITE_OK;
< 	//scorw end
< 	
63011,63013c62681
<       //scorw start
<       //rc = writeJournalHdr(pPager);
<       //scorw end
---
>       rc = writeJournalHdr(pPager);
63176,63177d62843
<   //printf("%s() called\n", __func__);
< 
63200d62865
<   //printf("%s(): pPager->eState==PAGER_WRITER_LOCKED? %d\n", __func__, pPager->eState==PAGER_WRITER_LOCKED);
63215d62879
<   //printf("%s(): pPager->pInJournal: %d\n", __func__,pPager->pInJournal);
63222,63225c62886
< 	//scorw start
<       //rc = pagerAddPageToRollbackJournal(pPg);
< 	rc = SQLITE_OK;
< 	//scorw end 
---
>       rc = pagerAddPageToRollbackJournal(pPg);
63249d62909
<   //printf("%s(): pPager->nSavepoint: %d\n", __func__, pPager->nSavepoint);
63380,63387c63040
< 	//double t1 = 0.0;
< 	//double t2 = 0.0;
< 	//t1 = what_time_is_it();
<     int ret = pager_write(pPg);
<     	//t2 = what_time_is_it();
< 	//printf("%s(): Writing to page: %u, %g\n", __func__, pPg->pgno, (t2-t1)*1000000);
<       
<     return ret;
---
>     return pager_write(pPg);
63611,63612d63263
<   //printf("%s() called\n");
< 
63791,63793d63441
<         //double t1 = 0.0;
<         //double t2 = 0.0;
<         //t1 = what_time_is_it();
63795,63796d63442
<         //t2 = what_time_is_it();
<         //printf("%s(): Time taken to write pages from page cache into database file: %g\n", __func__, (t2-t1)*1000000);
63819,63821d63464
<         //double t1 = 0.0;
<         //double t2 = 0.0;
<         //t1 = what_time_is_it();
63823,63824d63465
<         //t2 = what_time_is_it();
<         //printf("%s(): Time taken to sync database file: %g\n", __func__, (t2-t1)*1000000);
63953,63959d63593
<   //scorw start
<   if(rc==SQLITE_CORRUPT)
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
<   }
<   //printf("Rollback: db file name: %s\n", pPager->zFilename);
<   //scorw end 
64390d64023
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
66317,66321c65950
<       if( (nCollide--)==0 ) 
<       {
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	      return SQLITE_CORRUPT_BKPT;
<       }
---
>       if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;
67263d66891
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
68552d68179
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
69076d68702
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
69337d68962
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
70776d70400
<   //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71507d71130
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71706d71328
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71720d71341
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71726d71346
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71772d71391
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
71781,71785c71400
<   if( *pEType<1 || *pEType>5 ) 
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_PGNO(iPtrmap);
<   }
---
>   if( *pEType<1 || *pEType>5 ) return SQLITE_CORRUPT_PGNO(iPtrmap);
72225d71839
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72284,72288c71898
<     if( iFree>usableSize-4 ) 
<     {
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_PAGE(pPage);
<     }
---
>     if( iFree>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);
72291,72295c71901
<       if( iFree2>usableSize-4 ) 
<       {
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	      return SQLITE_CORRUPT_PAGE(pPage);
<       }
---
>       if( iFree2>usableSize-4 ) return SQLITE_CORRUPT_PAGE(pPage);
72303d71908
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72307,72311c71912
<           if( iFree+sz>iFree2 ) 
< 	  {
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 		  return SQLITE_CORRUPT_PAGE(pPage);
< 	  }
---
>           if( iFree+sz>iFree2 ) return SQLITE_CORRUPT_PAGE(pPage);
72313,72317c71914
<           if( iFree2+sz2 > usableSize ) 
< 	  {
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 		  return SQLITE_CORRUPT_PAGE(pPage);
< 	  }
---
>           if( iFree2+sz2 > usableSize ) return SQLITE_CORRUPT_PAGE(pPage);
72321d71917
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72355d71950
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72362d71956
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72377d71970
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72435d72027
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72451d72042
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72459d72049
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72508d72097
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72512d72100
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72530d72117
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72610d72196
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72616d72201
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72629,72633c72214
<       if( iEnd>iFreeBlk )
<       { 
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	      return SQLITE_CORRUPT_PAGE(pPage);
<       }
---
>       if( iEnd>iFreeBlk ) return SQLITE_CORRUPT_PAGE(pPage);
72636d72216
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72650,72654c72230
<         if( iPtrEnd>iStart )
< 	{	
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 		return SQLITE_CORRUPT_PAGE(pPage);
< 	}
---
>         if( iPtrEnd>iStart ) return SQLITE_CORRUPT_PAGE(pPage);
72660,72664c72236
<     if( nFrag>data[hdr+7] )
<     { 
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_PAGE(pPage);
<     }
---
>     if( nFrag>data[hdr+7] ) return SQLITE_CORRUPT_PAGE(pPage);
72678,72687c72250,72251
<     if( iStart<x ) 
<     {
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_PAGE(pPage);
<     }
<     if( iPtr!=hdr+1 )
<     { 
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_PAGE(pPage);
<     }
---
>     if( iStart<x ) return SQLITE_CORRUPT_PAGE(pPage);
>     if( iPtr!=hdr+1 ) return SQLITE_CORRUPT_PAGE(pPage);
72741d72304
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72766d72328
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72818d72379
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72824d72384
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72835d72394
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72840d72398
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72853d72410
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72885d72441
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72891d72446
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72924d72478
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
72939d72492
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
73083d72635
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
73156d72707
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
73988d73538
<   //printf("%s(): nPage: %d, nPageFile: %d\n", __func__, nPage, nPageFile);
73999,74000d73548
<     //printf("%s(): page1 %x, page1 contents: %x%x%x%x (should be 53 51 4c 69)\n", __func__, page1, page1[0], page1[1], page1[2], page1[3]);
<     //printf("%s(): page1 %x, page1 contents: %x%x%x%x (should be 74 65 20 66)\n", __func__, page1, page1[4], page1[5], page1[6], page1[7]);
74006d73553
<       //printf("%s(): page1 contents doesn't contain magic header. Throwing error.\n", __func__);
74099,74100d73645
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 		  printf("%s(): nPage: %d, nPageFile: %d\n", __func__, nPage, nPageFile);
74549d74093
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74569d74112
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74579d74121
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74592d74133
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74628,74632c74169
<   if( iDbPage<3 ) 
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( iDbPage<3 ) return SQLITE_CORRUPT_BKPT;
74730d74266
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74783d74318
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74852d74386
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74904d74437
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
74932,74936c74465
<     if( nFin>nOrig ) 
<     {
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_BKPT;
<     }
---
>     if( nFin>nOrig ) return SQLITE_CORRUPT_BKPT;
75009,75011d74537
<         //double t1 = 0.0;
<         //double t2 = 0.0;
<         //t1 = what_time_is_it();
75013,75014d74538
<         //t2 = what_time_is_it();
<         //printf("%s(): %g\n", __func__, (t2-t1)*1000000);
75100,75102d74623
<         //double t1 = 0.0;
<         //double t2 = 0.0;
<         //t1 = what_time_is_it();
75104,75105d74624
<         //t2 = what_time_is_it();
<         //printf("%s(): %g\n", __func__, (t2-t1)*1000000);
75240,75280d74758
<     //scorw start
< 
<     //printf("%s(): a) db file name: %s\n", __func__, pBt->pPager->zFilename);
< 
< 
<     //u32 tmp = 0;
<     //read32bits(pBt->pPager->fd, 28, &tmp);
<     //printf("%s(): File size stored in db file (on disk): %x\n", __func__, tmp);
< 
<     //Drop all pages like drop_caches in linux.
<     //Page1 is not dropped. Only its contents are set to 0.
<     pager_reset(pBt->pPager);
< 
<     //read contents of parent file and load them into page1
<     int page_size = 4096;
<     char buf[page_size];
< 
<     int parFD = open(pBt->pPager->zFilename, O_RDONLY);
<     assert(parFD >= 0);
< 
<     lseek(parFD, 0, SEEK_SET);
<     int ret = read(parFD, buf, page_size);
<     assert(ret == page_size);
< 
< 
<     //u32 tmp = 0;
<     //lseek(parFD, 28, SEEK_SET);
<     //ret = read(parFD, &tmp, 4);
<     //assert(ret);
< 
<     //printf("%s(): b) File (%s) size stored in db file (on disk): %x\n", __func__, pBt->pPager->zFilename, tmp);
< 
<     //char header[16];
<     //lseek(parFD, 0, SEEK_SET);
<     //ret = read(parFD, header, 16);
<     //assert(ret);
< 
<     //printf("%s(): c) File (%s) header stored in db file (on disk): %s\n", __func__, pBt->pPager->zFilename, header);
< 
<     close(parFD);
<     //scorw end
75286,75322d74763
< 
<       //scorw start
<       //Reset page1's contents to its on disk version
<       int i = 0;
<       PgHdr *pPgHdr;
<       sqlite3_pcache_page *cache_pPage1;
< 
<       //get page1 from page cache.
<       cache_pPage1 = sqlite3GlobalConfig.pcache2.xFetch(pBt->pPager->pPCache->pCache,1,0);
<       pPgHdr = (PgHdr*)cache_pPage1->pExtra;
< 
<       //Note:
<       //Each page in page cache is represented by struct PgHdr.
<       //struct PgHdr contains a member: pData that contains the contents of the page
<       //Also, struct PhHdr contains a member of type sqlite3_pcache_page
<       //This member also stores data (pBuf inside this structure)
<       //
<       //Compared and found that both contain same contents.
<       //Not sure which one will be used 
<       //
<       //Resetting both to the contents of the page read from disk.
< 
<       //printf("Rollback performed. [OLD Value of db Size] Byte 28: %x, 29: %x, 30: %x, 31: %x\n", ((char*)pPgHdr->pData)[28], ((char*)pPgHdr->pData)[29], ((char*)pPgHdr->pData)[30], ((char*)pPgHdr->pData)[31]);
<       for(i = 0; i < page_size; i++)
<       {
< 	      //printf("byte: %d, %d:%d:%d\n", i, pPage1->aData[i], ((char*)cache_pPage1->pBuf)[i], ((char*)pPgHdr->pData)[i]);
< 	      /*if(pPage1->aData[i] != ((char*)cache_pPage1->pBuf)[i])
< 	      {
< 		      printf("%s(): Page cache, byte: %d of page 1 is modified *********\n", __func__, i);
< 	      }*/
< 	      ((char*)cache_pPage1->pBuf)[i] = buf[i];
< 	      ((char*)pPgHdr->pData)[i] = buf[i];
<       }
<       //printf("\n");
<       //printf("Rollback performed. [NEW Value of db Size]. Byte 28: %x, 29: %x, 30: %x, 31: %x\n", ((char*)pPgHdr->pData)[28], ((char*)pPgHdr->pData)[29], ((char*)pPgHdr->pData)[30], ((char*)pPgHdr->pData)[31]);
<       //scorw end
< 
75488d74928
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
75894d75333
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
75910d75348
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
75976,75980c75414
<       if( nextPage > pBt->nPage ) 
<       {
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	      return SQLITE_CORRUPT_BKPT;
<       }
---
>       if( nextPage > pBt->nPage ) return SQLITE_CORRUPT_BKPT;
76064d75497
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76203d75635
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76218d75649
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76354d75784
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76367,76371c75797
<     if( pRoot->pgno!=1 ) 
<     {
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_BKPT;
<     }
---
>     if( pRoot->pgno!=1 ) return SQLITE_CORRUPT_BKPT;
76613d76038
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76810d76234
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76898d76321
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76931,76935c76354
<         if( pIdxKey->errCode ) 
< 	{
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 		rc = SQLITE_CORRUPT_BKPT;
< 	}
---
>         if( pIdxKey->errCode ) rc = SQLITE_CORRUPT_BKPT;
76966d76384
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
76978d76395
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77080d76496
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77174d76589
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77265d76679
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77322d76735
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77352d76764
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77387d76798
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77453d76863
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77581d76990
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77629d77037
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77641d77048
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77731d77137
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77749d77154
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
77770d77174
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
78024d77427
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
78414,78418c77817
<       if( ((uptr)(pCell+sz))>(uptr)pEnd )
<       { 
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	      return SQLITE_CORRUPT_BKPT;
<       }
---
>       if( ((uptr)(pCell+sz))>(uptr)pEnd ) return SQLITE_CORRUPT_BKPT;
78423d77821
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
78430,78434c77828
<     if( pData < pCellptr )
<     { 
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_BKPT;
<     }
---
>     if( pData < pCellptr ) return SQLITE_CORRUPT_BKPT;
78641,78645c78035
<     if( NEVER(nShift>nCell) )
<     { 
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_BKPT;
<     }
---
>     if( NEVER(nShift>nCell) ) return SQLITE_CORRUPT_BKPT;
78719,78723c78109
<   if( nNew<1 )
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( nNew<1 ) return SQLITE_CORRUPT_BKPT;
78763,78767c78149
<   if( pPage->nCell==0 )
<   { 
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;  /* dbfuzz001.test */
<   }
---
>   if( pPage->nCell==0 ) return SQLITE_CORRUPT_BKPT;  /* dbfuzz001.test */
79188d78569
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79213d78593
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79315,79318c78695
<         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT;
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__); 
< 		goto balance_cleanup; 
< 	}
---
>         if( k>NB+2 ){ rc = SQLITE_CORRUPT_BKPT; goto balance_cleanup; }
79351d78727
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79396d78771
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79430d78804
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79631d79004
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79864d79236
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
79925d79296
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80090d79460
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80119d79488
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80201d79569
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80325d79692
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80365d79731
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80393d79758
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80397d79761
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80500d79863
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80526d79888
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80623d79984
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80633d79993
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80638d79997
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80642d80000
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80734,80738c80092
<     if( pCell<&pLeaf->aData[4] )
<     { 
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_PAGE(pLeaf);
<     }
---
>     if( pCell<&pLeaf->aData[4] ) return SQLITE_CORRUPT_PAGE(pLeaf);
80854d80207
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80903d80255
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
80994d80345
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
81002d80352
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
81107d80456
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
81680d81028
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
81687d81034
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
84387d83733
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
85073,85077c84419
<   if( nHdr>nRec || iHdr>=nHdr ) 
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( nHdr>nRec || iHdr>=nHdr ) return SQLITE_CORRUPT_BKPT;
85083,85087c84425
<     if( iHdr>nHdr ) 
<     {
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	    return SQLITE_CORRUPT_BKPT;
<     }
---
>     if( iHdr>nHdr ) return SQLITE_CORRUPT_BKPT;
85093,85097c84431
<   if( iField>nRec )
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( iField>nRec ) return SQLITE_CORRUPT_BKPT;
88549d87882
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
88947,88951c88280
<   if( res!=0 )
<   { 
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT_BKPT;
<   }
---
>   if( res!=0 ) return SQLITE_CORRUPT_BKPT;
89458,89462c88787
<   if( szHdr1>98307 ) 
<   {
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
< 	  return SQLITE_CORRUPT;
<   }
---
>   if( szHdr1>98307 ) return SQLITE_CORRUPT;
89905d89229
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
89983d89306
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
90014d89336
< 		//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
90059d89380
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
90223d89543
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
90382d89701
<   //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
90416d89734
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
96633d95950
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
97467d96783
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
98888d98203
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
99971d99285
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
100177d99490
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
100458d99770
< 	      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
102487d101798
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
102514d101824
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
117403d116712
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
117415d116723
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
118375d117682
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
125844d125150
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
133419d132724
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
140758d140062
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
141608d140911
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
141616d140918
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
189463d188764
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
191977d191277
< 		  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
201138d200437
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
202876d202174
< 		      //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
202898d202195
< 		    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210193d209489
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210221d209516
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210251d209545
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210263d209556
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210274d209566
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
210861d210152
<   //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
211146d210436
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
211791d211080
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
211797d211085
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
212016d211303
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
212203d211489
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
213051d212336
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
219967d219251
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
220009d219292
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
221394d220676
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
223333d222614
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
227483d226763
< 	//printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
227504d226783
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
227515d226793
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
227564d226841
<       //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
227652d226928
< 	    //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
228154d227429
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
228285d227559
<     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
228638d227911
< 	     //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
239905,239907c239178
< static int sqlite3Fts5Corrupt() { //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__); 
< 	return SQLITE_CORRUPT_VTAB; 
< }
---
> static int sqlite3Fts5Corrupt() { return SQLITE_CORRUPT_VTAB; }
251655d250925
< 	  //printf("%s(), line: %u: SQLITE_CORRUPT, xyz\n", __func__, __LINE__);
